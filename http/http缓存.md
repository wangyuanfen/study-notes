## http报文首部字段中与缓存相关的字段

### 通用首部字段
* Cache-Control 控制缓存的行为
  * 缓存请求指令
  
    指令|说明
    --|--
    no-cache|告知缓存服务器不直接使用缓存，强制向源服务器再次验证
    no-store|所有内容都不会缓存或保存到缓存或者internet临时文件夹 
    max-age = [ 秒]|当客户端发送的请求中包含 max-age 指令时，判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。
    max-stale( = [ 秒])|接收已过期的响应。如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收
    min-fresh = [ 秒]|期望在指定时间内的响应仍有效，要求缓存服务器返回至少还未过指定时间的缓存资源
    no-transform|代理不可更改媒体类型。使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。
    only-if-cached|从缓存获取资源。使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout。 
    cache-extension|新指令标记（token）。自定义新指令，如果缓存服务器不能理解 community 这个新指令，就会直接忽略
    
  * 缓存响应指令
    
    指令|说明
    --|--
    public|任何情况下可向任意方提供响应的缓存
    private|缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，缓存服务器则不会返回缓存。
    no-cache|缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作
    no-store|所有内容都不会缓存或保存到缓存或者internet临时文件夹 
    no-transform|代理不可更改媒体类型。使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。
    must-revalidate|可缓存但必须再向源服务器进行确认。代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。另外，**使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）**
    proxy-revalidate|要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。
    max-age = [ 秒]|当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。
    s-maxage = [ 秒]|公共缓存服务器响应的最大Age值，只适用于供多位用户使用的公共缓存服务器
    cache-extension|新指令标记（token）。自定义新指令，如果缓存服务器不能理解 community 这个新指令，就会直接忽略
  
* Pragma 报文指令。
  * Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。
  * 规范定义的形式唯一，Pragma: no-cache。
  * 该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。Cache-Control: no-cache Pragma: no-cache

### 请求首部字段
* If-Match 比较实体标记（ETag）。
  * 会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。
  * 服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致 时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。
  * 还可以使用 星号 * 指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。
* If-None-Match 比较实体标记（与 If-Match 相反）
  * 会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。
  * If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。
* If-Modified-Since 比较资源的更新时间。指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。
* If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反）。告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。

### 响应首部字段
* E-Tag 资源的匹配信息
  * 首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。
  * 当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。
  * 资源被缓存时，就会被分配唯一性标识。
  * 强 ETag 值。不论实体发生多么细微的变化都会改变其值。ETag: "usagi-1234"
  * 弱 ETag 值。弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。ETag: W/"usagi-1234"

### 实体首部字段
* Expires 实体主体过期的日期时间。首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。
* Last-Modified 资源的最后修改日期时间。服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。

## 优先级

响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没意义。

Pragma -> Cache-Control -> Expires

应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略。

## 缓存实践
1、Expires / Cache-Control(本地缓存)

Expires用时刻来标识失效时间，不免收到时间同步的影响，而Cache-Control使用时间间隔很好的解决了这个问题。 但是 Cache-Control 是 HTTP1.1 才有的，不适用于 HTTP1.0，而 Expires 既适用于 HTTP1.0，也适用于 HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，会优先使用 Cache-Control。

2、Last-Modified / ETag(协商缓存)

二者都是通过某个标识值来请求资源，如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed）状态码，内容为空，这样就节省了传输数据量。而当资源发生比那话后，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。其中Last-Modified使用文件最后修改作为文件标识值，它无法处理文件一秒内多次修改的情况，而且只要文件修改了哪怕文件实质内容没有修改，也会重新返回资源内容；ETag作为“被请求变量的实体值”，其完全可以解决Last-Modified头部的问题，但是其计算过程需要耗费服务器资源。

3、from-cache / 304

Expires和Cache-Control都有一个问题就是服务端作为的修改，如果还在缓存时效里，那么客户端是不会去请求服务端资源的（非刷新），这就存在一个资源版本不符的问题，而强制刷新一定会发起HTTP请求并返回资源内容，无论该内容在这段时间内是否修改过；而Last-Modified和Etag每次请求资源都会发起请求，哪怕是很久都不会有修改的资源，都至少有一次请求响应的消耗。  
对于所有可缓存资源，指定一个Expires或Cache-Control max-age以及一个Last-Modified或ETag至关重要。同时使用前者和后者可以很好的相互适应。前者不需要每次都发起一次请求来校验资源时效性，后者保证当资源未出现修改的时候不需要重新发送该资源。而在用户的不同刷新页面行为中，二者的结合也能很好的利用HTTP缓存控制特性，无论是在地址栏输入URI然后输入回车进行访问，还是点击刷新按钮，浏览器都能充分利用缓存内容，避免进行不必要的请求与数据传输。

结论：
* 需要兼容HTTP1.0的时候需要使用Expires，不然可以考虑直接使用Cache-Control
* 需要处理一秒内多次修改的情况，或者其他Last-Modified处理不了的情况，才使用ETag，否则使用Last-Modified。
* 对于所有可缓存资源，需要指定一个Expires或Cache-Control，同时指定Last-Modified或者Etag。
* 可以通过标识文件版本名、加长缓存时间的方式来减少304响应。

[HTTP缓存控制小结](https://imweb.io/topic/5795dcb6fb312541492eda8c)
