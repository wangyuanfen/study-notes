## 定义
每当程序的执行流执行一段可执行的代码(executable code)时，会创建对应的执行上下文。  
举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，就叫做"执行上下文(execution context)"。
## 可执行代码
* 全局代码：程序载入后的默认环境，是运行在程序级别的代码。  
Web 浏览器中，全局代码被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的
* 函数代码：当执行流进入一个函数后。  
某个执行上下文中的所有代码执行完毕后，该上下文被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行上下文直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。
* Eval代码：Eval 内部的代码。
## 执行上下文栈(execution context stack)
执行流依次进入的执行上下文在逻辑上形成了一个栈(stack)，栈的底部永远是全局上下文，栈的顶部则是处于活动状态当前的执行上下文(running execution context)。例如，当执行流进入一个函数时，函数的上下文就会被推入一个栈中。而在函数执行之后，栈将其执行上下文弹出，把控制权返回给之前的执行上下文。ECMAScript程序中的执行流正是由这个方便的机制控制着。
## 执行上下文详解
* 变量对象(Variable object，VO)
每个执行上下文都有一个与之关联的变量对象，执行上下中定义的所有变量和函数都保存在这个对象中。  
如果这个执行上下文是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局上下中是不存在的）。
* 作用域链(Scope chain)
当代码在一个上下文中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行上下文有权访问的*所有*变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在上下文的变量对象。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从通过作用域链向上查找，一直找到全局上下文的变量对象，也就是全局对象。
* this
## 执行上下文步骤
