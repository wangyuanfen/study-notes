Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。
```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>
    <div>{{name}}</div>
    <script>
    	// 通过 Dep 解耦
    	class Dep {
    	  constructor() {
    	    this.subs = []
    	  }
    	  addSub(sub) {
    	    // sub 是 Watcher 实例
    	    this.subs.push(sub)
    	  }
    	  notify() {
    	    this.subs.forEach(sub => {
    	      sub.update()
    	    })
    	  }
    	}

    	function update(value) {
    	  document.querySelector('div').innerText = value
    	}

    	class Watcher {
    	  constructor(obj, key, cb) {
    	    // 将 Dep.target 指向自己
    	    // 然后触发属性的 getter 添加监听
    	    // 最后将 Dep.target 置空
    	    Dep.target = this
    	    this.cb = cb
    	    this.obj = obj
    	    this.key = key
    	    this.value = obj[key] // 在这里之前已经observe(data)，进行过数据的 set 和 get 的监听，所以会触发 getter，进行Watcher添加到订阅
    	    Dep.target = null
    	  }
    	  update() {
    	    // 获得新值
    	    this.value = this.obj[this.key]
    	    // 调用 update 方法更新 Dom
    	    this.cb(this.value)
    	  }
    	}

    	function observe(obj) {
    	  // 判断类型
    	  if (!obj || typeof obj !== 'object') {
    	    return
    	  }
    	  Object.keys(obj).forEach(key => {
    	    defineReactive(obj, key, obj[key])
    	  })
    	}

    	function defineReactive(obj, key, val) {
    	  // 递归子属性
    	  observe(val)
    	  let dp = new Dep()
    	  Object.defineProperty(obj, key, {
    	    enumerable: true,
    	    configurable: true,
    	    get: function reactiveGetter() {
    	      console.log('get value')
    	      // 将 Watcher 添加到订阅
    	      if (Dep.target) {
    	        dp.addSub(Dep.target)
    	      }
    	      return val
    	    },
    	    set: function reactiveSettexr(newVal) {
    	      console.log('change value')
    	      val = newVal
    	      // 执行 watcher 的 update 方法
    	      dp.notify()
    	    }
    	  })
    	}

    	// 全局属性，通过该属性配置 Watcher
    	Dep.target = null

    	var data = { name: 'yck' }

    	observe(data)
    	// 模拟解析到 `{{name}}` 触发的操作，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加
    	new Watcher(data, 'name', update)
    	// update Dom innerText
    	data.name = 'xxx'
    </script>
</body>
</html>
```
