## 原型

我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，
而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那
么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以
让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是
可以将这些信息直接添加到原型对象中.

    function Person(){  
    }  
    
    Person.prototype.name = "Nicholas";  
    Person.prototype.age = 29;  
    Person.prototype.job = "Software Engineer";  
    Person.prototype.sayName = function(){  
      alert(this.name);  
    };  
    
    var person1 = new Person();  
    person1.sayName(); //"Nicholas"  
    
    var person2 = new Person();  
    person2.sayName(); //"Nicholas"  
    
    alert(person1.sayName == person2.sayName); //true  
    
### prototype
无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype
属性，这个属性指向函数的原型对象。
### constructor
在默认情况下，所有原型对象都会自动获得一个 constructor
（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，
Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象
添加其他属性和方法。  
创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则
都是从 Object 继承而来的。
### \_\_proto\_\_(即[[Prototype]])
当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部
属性），指向构造函数的原型对象。 ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中
没有标准的方式访问[[Prototype]]，但 Firefox、 Safari 和 Chrome 在每个对象上都支持一个属性 \_\_proto\_\_；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就
是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。

![Alt text](https://user-images.githubusercontent.com/16177158/37645445-d4e03048-2c61-11e8-969a-cbf1d70222f1.jpg)

## 继承
### 原型链
ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原
型让一个引用类型继承另一个引用类型的属性和方法。  
简单回顾一下构造函数、原型和实例的关系：每
个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型
对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的
原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数
的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实
例与原型的链条。这就是所谓原型链的基本概念。

    function SuperType(){
        this.property = true;
    }
    
    SuperType.prototype.getSuperValue = function(){
        return this.property;
    };
    
    function SubType(){
        this.subproperty = false;
    }
    
    //继承了 SuperType
    SubType.prototype = new SuperType();
    
    SubType.prototype.getSubValue = function (){
        return this.subproperty;
    };
    
    var instance = new SubType();
    alert(instance.getSuperValue()); //true
    
![Alt text](https://user-images.githubusercontent.com/16177158/37648126-0a2cd768-2c69-11e8-9e84-822c58f2c02b.jpg)
![Alt text](http://img.keenwon.com/2016/03/20160314212504_39150.png)

    http://keenwon.com/1524.html
