## 可执行代码(executable code）
在ECMASscript中的代码有三种类型：**全局（global）**, **函数（function）**和**eval**。  

## 执行上下文（Execution context）
每一种代码的执行都需要依赖自身的上下文。
当然global的上下文可能涵盖了很多的function和eval的实例。
函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。
eval函数的每一次执行，也会进入eval执行中的上下文，判断应该从何处获取变量的值。  
执行上下文定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行上下文都有一个
与之关联的**变量对象（variable object）**，上下文中定义的所有变量和函数都保存在这个对象中。  

对于每个执行上下文，都有三个重要属性：

+   变量对象(Variable object，VO)
+   作用域链(Scope chain)
+   this

![Alt text](https://pic002.cnblogs.com/images/2011/349491/2011123113224058.png)

## 执行上下文栈（Execution context stack）

每个函数都有自己的**执行上下文**。当执行流进入一个函数时，函数的上下文就会被推入一个**执行上下文栈（Execution context stack）** 中。
而在函数执行之后，栈将其上下文弹出，把控制权返回给之前的执行上下文。

定义执行上下文栈是一个数组

    ECStack = [];
    
试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，
用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以 ECStack 最底部永远有个 globalContext：

    ECStack = [
        globalContext
    ];
    
代码

    function fun3() {
        console.log('fun3')
    }

    function fun2() {
        fun3();
    }

    function fun1() {
        fun2();
    }

    fun1();
    
当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出：

    // 伪代码

    // fun1()
    ECStack.push(<fun1> functionContext);

    // fun1中竟然调用了fun2，还要创建fun2的执行上下文
    ECStack.push(<fun2> functionContext);

    // 擦，fun2还调用了fun3！
    ECStack.push(<fun3> functionContext);

    // fun3执行完毕
    ECStack.pop();

    // fun2执行完毕
    ECStack.pop();

    // fun1执行完毕
    ECStack.pop();

    // javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
