## 递归

在数学和计算机科学中，递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。

一个很常见的例子是计算斐波那契数列：
```
function Fab(n) {
    if (n < 2) return 1;
    return Fab(n-1) + Fab(n-2);
}
```

需要注意的是，对于计算机科学来说，狭义的 “递归”，应当是在函数定义中，引用该函数自身的定义。

例如下面的代码不应视作递归，因为其未使用函数自身的定义：
```
function Hutia(){
    alert(String(Hutia));
}
```
## 递归会造成堆栈溢出    
在 OS / 浏览器 / ... 等平台运行程序的时候，每一次对函数的调用前，都会将当前的运行环境保存起来，以便于函数调用完毕后，恢复现场。这些数据，通常保存在堆栈里。一般在具体实现的时候，这个空间并不是无限的。也正是因此，函数的最大调用深度也是有限的。

由于递归函数的特点，导致如果边界检查存在缺陷，那么就可能导致超过这个最大深度，从而超出堆栈的存储能力，也就是一般所说的“溢出”。

## 优化递归

递归可以带来清晰、明确的代码表述，因此很多程序设计语言都保留了这个特性。但是由于保存运行环境，并为函数调用准备好入口的上下文，这些操作会带来额外的开销，因此在编译器不够给力的情况下，可以考虑将递归转换为循环，来优化性能。

## 回调的定义

回调函数在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其它代码的，某一块可执行代码的引用。

注意是 ：“某一块可执行代码的引用”。

因此，在 JavaScript 中，由于其 “事件驱动” （Event-Driven）的特性，使用像 "setTimeout"、 “nextTick” 等方式对指定函数的调用，实际上是将该函数的引用（指针）储存起来，并在适当的时候调用。

换句话说，JavaScript 中， "setTimeout"、 “nextTick” 等方式调用的函数，并不会形成类似于递归那样， “一层套一层” 的调用链。下一次函数调用时，上一个 “父” 函数的调用已经执行完毕。也就不存在堆栈溢出的风险了。

[怎样避免JavaScript中过长递归导致的堆栈溢出？ - tia hu的回答 - 知乎](https://www.zhihu.com/question/30078697/answer/46681063)
